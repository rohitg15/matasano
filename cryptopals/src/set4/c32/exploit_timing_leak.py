import sys
import socket
import time
import hmac

# This program requires python3
# it exploits a less artificial timing leak (about 5ms) in the HMAC verification function

if __name__ == "__main__":
    argc = len(sys.argv)
    if argc != 5:
        print("usage:%s host port message['file=filename'] hmac-length[bytes]") % (sys.argv[0])
        exit(0)
    host = sys.argv[1]
    port = int(sys.argv[2])
    message = sys.argv[3]
    mac_len = int(sys.argv[4])
    
    # hmac of the message 'foo' encrypted with key 'bar' is 85d155c55ed286a300bd1cf124de08d87e914f3a
    
    known_prefix = bytearray()
    # guess every byte of the mac
    for mac_idx in range(mac_len):
        # try all 256 values for each byte of the MAC
        table = {}
        for byte in range(256):
            # the guess string is the known_prefix (from previous iterations) + guess_byte + random_bytes totalling mac_len bytes
            guess_bytes = bytearray() + known_prefix
            guess_bytes.append(byte)
            for i in range(mac_len - len(known_prefix) - 1):
                guess_bytes.append(65)
            guess_hex = guess_bytes.hex()

            # start measuring time in clockticks
            start = time.perf_counter()

            # average out the number of attempts for every byte to smooth out any noise 
            # the number of rounds we execute here depends on the extent of the timing leak and might require some trial and error
            for times in range(3):
                # connect to http server
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((host, port))

                string_to_send = message + '&signature=' + guess_hex
                mbytearray = bytearray([ord(b) for b in string_to_send])
                nbytes = s.send(mbytearray)
                response = s.recv(1024)
                s.close()
            
            end = time.perf_counter()
            # compute a score table that stores the time taken for every byte that was guessed
            table[byte] = (end - start) * 1.0
            
        # sort the frequency distribution table and pick the byte with largest RTT as the answer
        sorted_table = sorted(table, key=lambda k : table[k], reverse=True)
        known_prefix.append(sorted_table[0])
        print("signature=" + known_prefix.hex())
        
    print("signature=" + known_prefix.hex())
    exit(0)